if not _G.hasRunOnce then
    _G.hasRunOnce = true
loadstring(game:HttpGet("https://rawscripts.net/raw/Universal-Script-Shiftlock-22314"))()

print("Shiftlock script is loaded!, if is computer, you will get ...")
print("Execute this script again, you need rejoin")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")

local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Parent = game.CoreGui
ScreenGui.DisplayOrder = math.huge

local Button = Instance.new("TextButton")
Button.Parent = ScreenGui
Button.Size = UDim2.new(0, 200, 0, 50)
Button.Position = UDim2.new(0, 0, 0, 0)
Button.Text = "Get Key"
Button.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
Button.TextColor3 = Color3.new(1, 1, 1)
Button.TextSize = 24
Button.AutoButtonColor = false

Button.MouseButton1Click:Connect(function()
    setclipboard("https://direct-link.net/1304866/new-go-checkpoint-2")
end)

local mm = Instance.new("UICorner", Button)
mm.CornerRadius = UDim.new(1, 0)

local function tweenTextSize(targetSize)
    local tween = TweenService:Create(Button, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {TextSize = targetSize})
    tween:Play()
end

Button.MouseEnter:Connect(function()
    tweenTextSize(30)
end)

Button.MouseLeave:Connect(function()
    tweenTextSize(24)
end)

local dragging = false
local lastPosition

Button.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        lastPosition = input.Position
    end
end)

Button.InputChanged:Connect(function(input)
    if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
        local delta = input.Position - lastPosition
        lastPosition = input.Position
        local newX = math.max(0, Button.Position.X.Offset + delta.X)
        Button.Position = UDim2.new(0, newX, 0, Button.Position.Y.Offset + delta.Y)
    end
end)

Button.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = false
        if Button.Position.X.Offset > 0 then
            local tween = TweenService:Create(Button, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Position = UDim2.new(0, 0, 0, Button.Position.Y.Offset)})
            tween:Play()
        end
    end
end)

local ff = Instance.new("Frame", Button)
ff.Size = UDim2.new(0, 30, 1, 0)
ff.BorderSizePixel = 0
ff.BackgroundColor3 = Color3.new(0, 0, 0)
ff.ZIndex = 0
local sou = Instance.new("Sound", game.Workspace)
sou.SoundId = "rbxassetid://4809574295"
sou.Volume = 1
sou.Name = math.random(1000000, 99999999)

local willget = game.CoreGui
local SG = Instance.new("ScreenGui", willget)
SG.Name = "sg123"
local wa = Instance.new("TextLabel", SG)
wa.Text = "*Added functionality to the button but it's still lacking"
wa.Name = "textr"
wa.Position = UDim2.new(0.5, 0, 0.8, 0)
wa.TextSize = 14
wa.TextColor3 = Color3.fromRGB(255, 0, 0)
wa.Visible = false
wa.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
wa.TextStrokeTransparency = 0

local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
local Window = Rayfield:CreateWindow({
   Name = "TD 1.31 - V2025_2_28",
   Icon = 0,
   LoadingTitle = "Wait...",
   LoadingSubtitle = "by neoxhackbiem(number)",
   Theme = "Amethyst",

   KeySystem = true,
   KeySettings = {
      Title = "TD 1.3 Script!",
      Subtitle = "Key System",
      Note = "Permanent Key", 
      FileName = "Key_System_91",
      SaveKey = true,
      GrabKeyFromSite = false, 
      Key = {"1259851374"}
   }
})

sou:Play()

local player = game.Players.LocalPlayer

local function enableClimbing()
    while true do
        local character = player.Character
        if character then
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid:SetStateEnabled(Enum.HumanoidStateType.Climbing, true)
            end
        end
        wait(5)
    end
end

task.spawn(enableClimbing)

player.CharacterAdded:Connect(function()
    task.spawn(enableClimbing)
end)

local Players = game:GetService("Players")

local targetNames = {
    ["neoxhackbiem"] = true,
    ["ace1991ace"] = true
}

for i = 1, 18 do
    targetNames["neoxhackbiem" .. i] = true
end

local function checkPlayer(player)
    if targetNames[string.lower(player.Name)] then
        Rayfield:Notify({
            Title = "Warning",
            Content = "Player " .. player.Name .. " has joined the game! The creator of this script has entered the game ",
            Duration = 6.5,
            Image = "rewind",
        })
    end
end

for _, player in ipairs(Players:GetPlayers()) do
    checkPlayer(player)
end

Players.PlayerAdded:Connect(checkPlayer)

local Tab = Window:CreateTab("Main", 10814531047)

local Dropdown = Tab:CreateDropdown({
    Name = "Select Character",
    Options = {"amy", "blaze", "cream", "eggman", "knuckles", "metalsonic", "rouge", "sally", "shadow", "silver", "tails"},
    CurrentOption = {"amy"},
    MultipleOptions = false,
    Flag = "Dropdown1",
    Callback = function(Options)
        selectedCharacter = Options[1]
    end,
})

local autoMorph = false
local Toggle = Tab:CreateToggle({
    Name = "Auto Morph",
    CurrentValue = false,
    Flag = "Toggle1",
    Callback = function(Value)
        autoMorph = Value
    end,
})

game:GetService("RunService").RenderStepped:Connect(function()
    if autoMorph and selectedCharacter then
        game.ReplicatedStorage.remotes.morphs:FireServer(selectedCharacter)
    end
end)

local Dropdown = Tab:CreateDropdown({
   Name = "Emotes",
   Options = {"angry", "glad", "surprised", "sad", "happy", "worried", "confused", "tired", "enraged", "hurt"},
   CurrentOption = {"Choose Emote"},
   MultipleOptions = false,
   Flag = "Dropdown1",
 Callback = function(Options)
       if Options[1] ~= "none" then
           local args = {
               [1] = Options[1]
           }
           game:GetService("ReplicatedStorage"):WaitForChild("remotes"):WaitForChild("expressions"):FireServer(unpack(args))
       end
   end,
})
local Dropdown = Tab:CreateDropdown({
   Name = "Eyes",
   Options = {"bloodshot", "regularEyes", "removeBloodshot", "scaredEyes"},
   CurrentOption = {"Choose Eyes"},
   MultipleOptions = false,
   Flag = "Dropdown1",
   Callback = function(Options)
       if Options[1] ~= "none" then
           local args = {
               [1] = Options[1]
           }
           game:GetService("ReplicatedStorage"):WaitForChild("remotes"):WaitForChild("expressions"):FireServer(unpack(args))
       end
   end,
})
local Dropdown = Tab:CreateDropdown({
   Name = "Wound",
   Options = {"torsoBlood", "noseWound", "neckWound", "mouthBlood", "headWounds"},
   CurrentOption = {"Choose Wound"},
   MultipleOptions = false,
   Flag = "Dropdown1",
   Callback = function(Options)
       if Options[1] ~= "none" then
           local args = {
               [1] = Options[1]
           }
           game:GetService("ReplicatedStorage"):WaitForChild("remotes"):WaitForChild("expressions"):FireServer(unpack(args))
       end
   end,
})

local Toggle = Tab:CreateToggle({
   Name = "Toggle Debug",
   CurrentValue = false,
   Flag = "Ya",  
   Callback = function(Value)
game.Players.LocalPlayer.PlayerGui.gui.hud.debug.Visible = Value
game.CoreGui.sg123.textr.Visible = Value

-- Emote
local player = game.Players.LocalPlayer
local gui = player:WaitForChild("PlayerGui"):WaitForChild("gui"):WaitForChild("hud"):WaitForChild("debug"):WaitForChild("expressionList")

local expressionsFolder = gui:WaitForChild("expressions")
local statesFolder = gui:WaitForChild("states")
local woundsFolder = gui:WaitForChild("wounds")

local function addButtonEvent(button)
    button.MouseButton1Click:Connect(function()
        local args = {
            [1] = button.Name
        }
        game:GetService("ReplicatedStorage"):WaitForChild("remotes"):WaitForChild("expressions"):FireServer(unpack(args))
    end)
end

local function setupButtons(folder)
    for _, button in pairs(folder:GetChildren()) do
        if button:IsA("TextButton") or button:IsA("ImageButton") then
            addButtonEvent(button)
        end
    end
end

setupButtons(expressionsFolder)
setupButtons(statesFolder)
setupButtons(woundsFolder)
-- Actions
local player = game.Players.LocalPlayer
local actions = player:WaitForChild("PlayerGui"):WaitForChild("gui"):WaitForChild("hud"):WaitForChild("debug"):WaitForChild("actions")
local TweenService = game:GetService("TweenService")
-- reset
local resetButton = actions:WaitForChild("reset")
resetButton.MouseButton1Click:Connect(function()
    local character = player.Character
    if character then
        character:BreakJoints()
        player:LoadCharacter()
    end
end)

-- stunned
local stunnedButton = actions:WaitForChild("stunned")
stunnedButton.MouseButton1Click:Connect(function()
    local args = {
        [1] = "buzzsawHit",
        [2] = workspace:WaitForChild("game"):WaitForChild("currentMap"):WaitForChild("you can't run"):WaitForChild("mechanics"):WaitForChild("buzzsaws"):WaitForChild("20")
    }
    game:GetService("ReplicatedStorage"):WaitForChild("remotes"):WaitForChild("actions"):FireServer(unpack(args))
end)
-- morph
local characterList = game.Players.LocalPlayer.PlayerGui.gui.hud.debug.characterList:GetChildren()

for _, button in pairs(characterList) do
    if button:IsA("TextButton") then
        button.MouseButton1Click:Connect(function()
            local args = {
                [1] = button.Text
            }

            game:GetService("ReplicatedStorage"):WaitForChild("remotes"):WaitForChild("morphs"):FireServer(unpack(args))
        end) 
    end
end
end,
})

local isEnabled = false
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Toggle = Tab:CreateToggle({
   Name = "Big Hitbox (Make Easy Attack)",
   CurrentValue = false,
   Flag = "ToggleEasyAttack", 
   Callback = function(Value)
       isEnabled = Value
   end,
})

local function UpdateHitbox()
    if isEnabled then
        for _, player in ipairs(Players:GetPlayers()) do
            local args = {
                [1] = workspace:WaitForChild(player.Name)
            }
            ReplicatedStorage:WaitForChild("remotes"):WaitForChild("hitReg"):FireServer(unpack(args))
        end
    end
end

Players.PlayerAdded:Connect(UpdateHitbox)
Players.PlayerRemoving:Connect(UpdateHitbox)

spawn(function()
    while true do
        wait()
        UpdateHitbox()
    end
end)

Tab:CreateButton({
Name = "Keep the same morph for the next match\n (Not work in the 3rd match)",
Callback = function()
local player = game.Players.LocalPlayer
local humanoid = player.Character and player.Character:FindFirstChildWhichIsA("Humanoid")

if humanoid then
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Dead, false)
    humanoid.HealthChanged:Connect(function(health)
        if health < 9999999999999999 then
            humanoid.Health = 99999999999999999999999999999
        end
    end)
end
end,
})

local espExeEnabled = false
local espPlayersEnabled = false

local exeTag = "exe"
local highlightMap = {}

local function createHighlight(exeObject, color)
    local existingHighlight = exeObject:FindFirstChildOfClass("Highlight")
    if existingHighlight then
        existingHighlight:Destroy()
    end
    
    local highlight = Instance.new("Highlight")
    highlight.Parent = exeObject
    highlight.FillColor = color
    highlight.FillTransparency = 0.5
    highlight.OutlineTransparency = 0
end

local function onExeAdded(exeObject)
    if exeObject:IsA("Model") and exeObject:FindFirstChild("Humanoid") then
        createHighlight(exeObject, Color3.fromRGB(255, 0, 0))
    end
end

local function setupExeDetector()
    local exeCollectionService = game:GetService("CollectionService")
    
    for _, exeObject in pairs(exeCollectionService:GetTagged(exeTag)) do
        onExeAdded(exeObject)
    end

    exeCollectionService:GetInstanceAddedSignal(exeTag):Connect(onExeAdded)
end

local function toggleExeEsp(state)
    if state then
        setupExeDetector()
    else
        for _, exeObject in pairs(game:GetService("CollectionService"):GetTagged(exeTag)) do
            local existingHighlight = exeObject:FindFirstChildOfClass("Highlight")
            if existingHighlight then
                existingHighlight:Destroy()
            end
        end
    end
end

local characterColors = {
    tails = Color3.fromRGB(255, 165, 0),
    knuckles = Color3.fromRGB(255, 0, 0),
    eggman = Color3.fromRGB(255, 255, 0),
    amy = Color3.fromRGB(255, 105, 180),
    cream = Color3.fromRGB(255, 218, 185),
    sally = Color3.fromRGB(210, 180, 140),
    shadow = Color3.fromRGB(0, 0, 0),
    rouge = Color3.fromRGB(255, 255, 255),
    blaze = Color3.fromRGB(128, 0, 128),
    silver = Color3.fromRGB(192, 192, 192),
    metalsonic = Color3.fromRGB(0, 0, 255),
    kolossos = Color3.fromRGB(139, 0, 0),
    sonicexe = Color3.fromRGB(139, 0, 0),
}

local function loopThroughDisplayPlayers()
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local displayPlayersFolder = ReplicatedStorage:FindFirstChild("displayPlayers")
    if not displayPlayersFolder then return end

    for modelName, highlight in pairs(highlightMap) do
        if not displayPlayersFolder:FindFirstChild(modelName) then
            highlight:Destroy()
            highlightMap[modelName] = nil
        end
    end

    for _, child in pairs(displayPlayersFolder:GetChildren()) do
        local stats = child:FindFirstChild("stats")
        if stats and stats:FindFirstChild("character") then
            local givenCharacter = stats.character.Value:lower()
            local color = characterColors[givenCharacter]

            if color then
                local model = workspace:FindFirstChild(child.Name)
                if model and model:IsA("Model") then
                    if not highlightMap[model.Name] then
                        local highlight = Instance.new("Highlight")
                        highlight.FillColor = color
                        highlight.FillTransparency = 0.3
                        highlight.OutlineColor = color
                        highlight.OutlineTransparency = 0.2
                        highlight.Enabled = true
                        highlight.Adornee = model
                        highlight.Parent = workspace
                        highlightMap[model.Name] = highlight
                    else
                        local highlight = highlightMap[model.Name]
                        highlight.FillColor = color
                        highlight.OutlineColor = color
                    end
                end
            end
        end
    end
end

local function togglePlayersEsp(state)
    if state then
        espPlayersEnabled = true
        while espPlayersEnabled do
            loopThroughDisplayPlayers()
            wait(1)
        end
    else
        espPlayersEnabled = false
        for _, highlight in pairs(highlightMap) do
            highlight:Destroy()
        end
        highlightMap = {}
    end
end

local ToggleExe = Tab:CreateToggle({
    Name = "ESP Exe",
    CurrentValue = false,
    Flag = "ToggleExe",
    Callback = function(Value)
        espExeEnabled = Value
        toggleExeEsp(espExeEnabled)
    end,
})

local TogglePlayers = Tab:CreateToggle({
    Name = "ESP Survivor",
    CurrentValue = false,
    Flag = "TogglePlayers",
    Callback = function(Value)
        espPlayersEnabled = Value
        togglePlayersEsp(espPlayersEnabled)
    end,
})

local Tab = Window:CreateTab("Teleport", 6723742952)
Tab:CreateButton({
Name = "Teleport to Lobby",
Callback = function()
game.Players.LocalPlayer.Character:MoveTo(Vector3.new(0, 10, 0))
end,
})
Tab:CreateButton({
Name = "Teleport to Game (Can fall the void)",
Callback = function()
game.Players.LocalPlayer.Character:MoveTo(Vector3.new(-272, 155, -313))
end,
})
local Tab = Window:CreateTab("Animations", 110748588642372)
Tab:CreateButton({
	Name = "Stop animation",
	Callback = function()
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")

for _, animationTrack in pairs(humanoid:GetPlayingAnimationTracks()) do
    animationTrack:Stop(0)
end
  	end,    
})

local Animations = {
    { Name = "Sonic.exe 2 Idle", Id = "rbxassetid://137659262960225" },
    { Name = "Tails Cannon", Id = "rbxassetid://138560715967682" },
    { Name = "Tails Glide", Id = "rbxassetid://136705072136812" },
    { Name = "Amy Arm Idle", Id = "rbxassetid://16548210127" },
    { Name = "Cream Heal", Id = "rbxassetid://14472382960" },
    { Name = "Downed 2", Id = "rbxassetid://129121832899238" },
    { Name = "Injured 2", Id = "rbxassetid://116366098474267" },
{ Name = "Beaten", Id = "rbxassetid://14526473340" },
{ Name = "Tackled", Id = "rbxassetid://16233637794" },
{ Name = "knuckles punch 2", Id = "rbxassetid://125567395811973" },
{ Name = "Sonic.exe 2 attack", Id = "rbxassetid://16246380498" },
{ Name = " Sonic.exe 2 Changer 2", Id = "rbxassetid://95255389214022"},
{ Name = "Eggman Test 1", Id = "rbxassetid://74930208619120" },
{ Name = "Eggman Test 2", Id = "rbxassetid://90114877445120" }
}

local function PlayAnimation(animationId)
    local character = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
    local humanoid = character:WaitForChild("Humanoid")
    local animator = humanoid:FindFirstChild("Animator") or humanoid:WaitForChild("Animator")
    local animation = Instance.new("Animation")
    animation.AnimationId = animationId
    local track = animator:LoadAnimation(animation)
    track:Play()
end

for _, anim in ipairs(Animations) do
    Tab:CreateButton({
        Name = anim.Name,
        Callback = function()
            PlayAnimation(anim.Id)
        end
    })
end

Tab:CreateButton({
Name = "Get More? Click Here",
Callback = function()
loadstring(game:HttpGet("https://raw.githubusercontent.com/Biem6ondo/Test/refs/heads/main/Testing"))()
end,
})


local Tab = Window:CreateTab("Survivor", 135443303437470)
local loopRunning = false

local ReviveActions = Tab:CreateToggle({
   Name = "Auto Revive (Alway Revive Actions)",
   CurrentValue = false,
   Flag = "Toggle1",
   Callback = function(Value)
       loopRunning = Value
       if loopRunning then
           task.spawn(function()
               while loopRunning do
                   for _, player in ipairs(game:GetService("Players"):GetPlayers()) do
                       local args = {
                           [1] = "revive",
                           [2] = workspace:FindFirstChild(player.Name)
                       }
                       if args[2] then
                           game:GetService("ReplicatedStorage"):WaitForChild("remotes"):WaitForChild("actions"):FireServer(unpack(args))
                       end
                   end
                   task.wait()
               end
           end)
       end
   end,
})

local Players = game:GetService("Players")
local playerNames = {}
for _, player in pairs(Players:GetPlayers()) do
    table.insert(playerNames, player.Name)
end

local Dropdown = Tab:CreateDropdown({
    Name = "Choose Player To Heal (Need Cream)",
    Options = playerNames,
    CurrentOption = {"None"},
    MultipleOptions = false,
    Flag = "Dropdown1",
    Callback = function(Options)
        local selectedPlayer = Options[1]
        local args = {
            [1] = "overheal",
            [2] = workspace:WaitForChild(selectedPlayer)
        }
        game:GetService("ReplicatedStorage"):WaitForChild("remotes"):WaitForChild("abilities"):FireServer(unpack(args))
    end,
})

Players.PlayerAdded:Connect(function(player)
    table.insert(playerNames, player.Name)
    Dropdown:Refresh(playerNames)
end)

Players.PlayerRemoving:Connect(function(player)
    for i, name in ipairs(playerNames) do
        if name == player.Name then
            table.remove(playerNames, i)
            break
        end
    end
    Dropdown:Refresh(playerNames)
end)
local Players = game:GetService("Players")
local playerNames = {}
for _, player in pairs(Players:GetPlayers()) do
    table.insert(playerNames, player.Name)
end

local Dropdown = Tab:CreateDropdown({
    Name = "Choose Player To Shield (Need Sally)",
    Options = playerNames,
    CurrentOption = {"?"},
    MultipleOptions = false,
    Flag = "Dropdown1",
    Callback = function(Options)
        local selectedPlayer = Options[1]
        local args = {
            [1] = "shieldShare",
            [2] = workspace:WaitForChild(selectedPlayer)
        }
        game:GetService("ReplicatedStorage"):WaitForChild("remotes"):WaitForChild("abilities"):FireServer(unpack(args))
    end,
})

Players.PlayerAdded:Connect(function(player)
    table.insert(playerNames, player.Name)
    Dropdown:Refresh(playerNames)
end)

Players.PlayerRemoving:Connect(function(player)
    for i, name in ipairs(playerNames) do
        if name == player.Name then
            table.remove(playerNames, i)
            break
        end
    end
    Dropdown:Refresh(playerNames)
end)

Tab:CreateButton({
Name = "Dead right now",
Callback = function()
local args = {
    [1] = "drown"
}

game:GetService("ReplicatedStorage"):WaitForChild("remotes"):WaitForChild("actions"):FireServer(unpack(args))
end,
})
local Paragraph = Tab:CreateParagraph({Title = "[❓] Enable Abilities No Countdown Req.", Content = "You Need Click DEAD RIGHT NOW, and be exe, then toggle ABILITIES NO COUNTDOWN from SONIC.EXE AND MINIONS\nLet fun with abilities no countdown!"})

local Dropdown
local playerNames = {}
local selectedPlayers = {} 
local currentIndex = 1
local runningGrapple = false
local runningHeatWave = false
local runningOrb = false
local runningflashbang = false
local homingAttack = false

local function updatePlayerList()
    local newPlayerNames = {}
    for _, player in ipairs(game.Players:GetPlayers()) do
        table.insert(newPlayerNames, player.Name)
    end

    if #newPlayerNames ~= #playerNames then
        playerNames = newPlayerNames
        if Dropdown then
            Dropdown:Refresh(playerNames) 
        end
    end
end

Dropdown = Tab:CreateDropdown({
    Name = "Choose Players",
    Options = playerNames,
    CurrentOption = {"Choose!"},
    MultipleOptions = true,
    Flag = "Dropdown1",
    Callback = function(Options)
        selectedPlayers = Options
        currentIndex = 1
    end,
})

local function getNextPlayer()
    if #selectedPlayers == 0 then return nil end
    local playerName = selectedPlayers[currentIndex]
    currentIndex = (currentIndex % #selectedPlayers) + 1 
    return game.Players:FindFirstChild(playerName) and game.Players[playerName].Character
end

local function metal()
    local target = getNextPlayer()
    if target then
        local r = game.ReplicatedStorage.remotes
        r.abilities:FireServer("grapple", target, Vector3.new(0, 0, 0))
    end
end

local function castHeatWave()
    local target = getNextPlayer()
    if target and target:FindFirstChild("HumanoidRootPart") then
        local cf = target.HumanoidRootPart.CFrame
        local r = game.ReplicatedStorage.remotes
        r.abilities:FireServer("heatWave")
        r.abilities:FireServer("releaseHeatWave", cf)
    end
end

local function castOrb()
    local target = getNextPlayer()
    local r = game.ReplicatedStorage.remotes
    r.abilities:FireServer("orb") 

    if target and target:FindFirstChild("HumanoidRootPart") then
        r.abilities:FireServer("throwOrb", target.HumanoidRootPart.Position)
    end
end

local function flashbang()
    local target = getNextPlayer()
    if target and target:FindFirstChild("HumanoidRootPart") then
        local pos = target.HumanoidRootPart.Position - Vector3.new(0, 3, 0)
        local r = game.ReplicatedStorage.remotes
        r.abilities:FireServer("flashbang", pos)
    end
end

local function homingAttackAction()
    local target = getNextPlayer()
    if target then
        local r = game.ReplicatedStorage.remotes
r.abilities:FireServer("homingAttack")
        r.abilities:FireServer("homingAttackTarget", target)
    end
end

local ToggleGrapple = Tab:CreateToggle({
    Name = "Start (Spam Grapple Abilities / Need To Get Closer)",
    CurrentValue = false,
    Flag = "toggle_grapple",
    Callback = function(Value)
        runningGrapple = Value
        while runningGrapple do
            metal()
            task.wait()
        end
    end,
})

local ToggleHeatWave = Tab:CreateToggle({
    Name = "Start (Spam HeatWave Abilities)",
    CurrentValue = false,
    Flag = "toggle_heatwave",
    Callback = function(Value)
        runningHeatWave = Value
        while runningHeatWave do
            castHeatWave()
            task.wait()
        end
    end,
})

local ToggleOrb = Tab:CreateToggle({
    Name = "Start (Spam Orb Abilities / Can't Stun)",
    CurrentValue = false,
    Flag = "toggle_orb",
    Callback = function(Value)
        runningOrb = Value
        while runningOrb do
            castOrb()
            task.wait()
        end
    end,
})

local ToggleFlashBang = Tab:CreateToggle({
    Name = "Start (Spam Flashbang Abilities / Need To Get Closer)",
    CurrentValue = false,
    Flag = "toggle_flashbang",
    Callback = function(Value)
        runningflashbang = Value
        while runningflashbang do
            flashbang()
            task.wait()
        end
    end,
})

local ToggleHomingAttack = Tab:CreateToggle({
    Name = "Start (Spam HomingAttack Abilities / Need To Get Closer)",
    CurrentValue = false,
    Flag = "aiq",
    Callback = function(Value)
        homingAttack = Value
        while homingAttack do
            homingAttackAction()
            task.wait()
        end
    end,
})

task.spawn(function()
    while true do
        updatePlayerList()
        task.wait(2)
    end
end)

_G.PlayerPosition = nil
local ToggleActive = false

spawn(function()
    while wait(0) do
        local player = game:GetService("Players").LocalPlayer
        if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            _G.PlayerPosition = player.Character.HumanoidRootPart.Position
        end
    end
end)

local Label = Tab:CreateLabel("Spam Abilities (Not Players Req.)", "blocks")

local SliverBarrier = Tab:CreateToggle({
   Name = "Spam Barrier (Sliver)",
   CurrentValue = false,
   Flag = "Toggle1",
   Callback = function(Value)
       ToggleActive = Value
       if ToggleActive then
           spawn(function()
               while ToggleActive do
                   local args1 = { [1] = "barrier" }
                   game:GetService("ReplicatedStorage"):WaitForChild("remotes"):WaitForChild("abilities"):FireServer(unpack(args1))
                   
                   local args2 = { 
                       [1] = "placeBarrier", 
                       [2] = CFrame.new(_G.PlayerPosition or Vector3.new(0, 0, 0))
                   }
                   game:GetService("ReplicatedStorage"):WaitForChild("remotes"):WaitForChild("abilities"):FireServer(unpack(args2))

                   wait(0)
               end
           end)
       end
   end,
})

local ToggleActive = false
local Shadow_homingAttackState_attacking = Tab:CreateToggle({
   Name = "Spam HomingAttackState: Attacking / Like Spam Sound (shadow)",
   CurrentValue = false,
   Flag = "Toggle1",
   Callback = function(Value)
       ToggleActive = Value
       if ToggleActive then
           spawn(function()
               while ToggleActive do
                   local args = {
                       [1] = "homingAttackState",
                       [2] = "attacking"
                   }
                   game:GetService("ReplicatedStorage"):WaitForChild("remotes"):WaitForChild("abilities"):FireServer(unpack(args))
                   task.wait()
               end
           end)
       end
   end,
})

local ToggleActive = false
local Shadow_boostState_landed = Tab:CreateToggle({
   Name = "Spam BoostState: Landed / Make Everyone Has Camera Shake (shadow)",
   CurrentValue = false,
   Flag = "Toggle1",
   Callback = function(Value)
       ToggleActive = Value
       if ToggleActive then
           spawn(function()
               while ToggleActive do
local args = {
    [1] = "boostState",
    [2] = "landed"
}

game:GetService("ReplicatedStorage").remotes.abilities:FireServer(unpack(args))

                   task.wait()
               end
           end)
       end
   end,
})

local Tab = Window:CreateTab("Sonic.exe and minion", 73545495297148)
local teleporting = false
local targetPlayer = nil

local displayPlayers = game:GetService("ReplicatedStorage"):FindFirstChild("displayPlayers")
if not displayPlayers then
    warn("Target: Cannot Found (Fail)")
    return
end

local function getNextPlayerWithHealth()
    for _, playerFolder in ipairs(displayPlayers:GetChildren()) do
        if playerFolder:IsA("Folder") then
            local health = playerFolder:FindFirstChild("health")
            if health and health.Value > 0 then
                local player = game.Players:FindFirstChild(playerFolder.Name)
                if player then
                    return player
                end
            end
        end
    end
    return nil
end

local function teleportToPlayer()
    while teleporting do
        targetPlayer = getNextPlayerWithHealth()
        
        if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local playerRoot = game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            local targetRoot = targetPlayer.Character.HumanoidRootPart
            if playerRoot then
                playerRoot.CFrame = targetRoot.CFrame + Vector3.new(0, 0, 0)
            end

            local args = {
                [1] = "attack"
            }
            game:GetService("ReplicatedStorage"):WaitForChild("remotes"):WaitForChild("abilities"):FireServer(unpack(args))

            local minionArgs = {
                [1] = "minionAttack"
            }
            game:GetService("ReplicatedStorage"):WaitForChild("remotes"):WaitForChild("abilities"):FireServer(unpack(minionArgs))

            for _, player in ipairs(game:GetService("Players"):GetPlayers()) do
                local args = {
                    [1] = workspace:WaitForChild(player.Name)
                }
                game:GetService("ReplicatedStorage"):WaitForChild("remotes"):WaitForChild("hitReg"):FireServer(unpack(args))
            end
        end
        wait(0)
    end
end

local canturnoffa = Tab:CreateToggle({
    Name = "Kill All",
    CurrentValue = false,
    Flag = "ToggleKillAll",
    Callback = function(Value)
        teleporting = Value
        if teleporting then
            teleportToPlayer()
        end
    end,
})


local runningm = false 

local canturnoff = Tab:CreateToggle({
   Name = "Abilities No Countdown",
   CurrentValue = false,
   Flag = "LaserHitToggle",
   Callback = function(Value)
      runningm = Value 
      if runningm then
         while runningm and wait() do
            game:GetService("ReplicatedStorage"):WaitForChild("remotes"):WaitForChild("infect"):FireServer()
            
            local player = game.Players.LocalPlayer
            local stats = player:WaitForChild("PlayerGui"):WaitForChild("stats")
            
            if stats then
               stats:SetAttribute("isDead", false)
            end
         end
      end
   end,
})

local player = game.Players.LocalPlayer
local toggleEnabled = false

local function trapAbility()
    while toggleEnabled do
        wait()
        local character = player.Character
        if character and character:FindFirstChild("HumanoidRootPart") then
            local args = {
                [1] = "trap",
                [2] = character.HumanoidRootPart.Position - Vector3.new(0, 3, 0)
            }
            game:GetService("ReplicatedStorage"):WaitForChild("remotes"):WaitForChild("abilities"):FireServer(unpack(args))
        end
    end
end

local TailsDollTrap = Tab:CreateToggle({
    Name = "Spam Trap Abilities (TailsDoll / Need Enable No Abilities Countdown)",
    CurrentValue = false,
    Flag = "ToggleTrap",
    Callback = function(Value)
        toggleEnabled = Value
        if toggleEnabled then
            trapAbility()
        end
    end,
})

player.CharacterAdded:Connect(function()
    wait(1)
    if toggleEnabled then
        trapAbility()
    end
end)

local TailsDollSlash = Tab:CreateToggle({
    Name = "Spam Slash Abilities (TailsDoll)",
    CurrentValue = false,
    Flag = "Toggle1",
    Callback = function(Value)
        _G.SlashToggle = Value
    end,
})

_G.SlashToggle = false

spawn(function()
    while true do
        wait(0)
        if _G.SlashToggle then
            game.ReplicatedStorage.remotes.abilities:FireServer("slash")
        end
    end
end)

local previousHealth = 0
local function checkHealthChange()
    while teleporting do
        local player, healthValue = getNextPlayerWithHealth()
        if player and healthValue ~= previousHealth and healthValue > 0 then
            previousHealth = healthValue
            teleporting = false

            if healthValue > 0 then
                teleporting = true
                teleportToPlayer()
            end
        end
        task.wait(1)
    end
end

task.spawn(checkHealthChange)
local Tab = Window:CreateTab("Client", 9405930424)

local Input = Tab:CreateInput({
   Name = "Set your health",
   CurrentValue = "",
   PlaceholderText = "Data",
   Flag = "Input1", 
   Callback = function(setdata)
local playerName = game.Players.LocalPlayer.Name
local newHealthValue = setdata

local replicatedStorage = game:GetService("ReplicatedStorage")
local displayPlayers = replicatedStorage:FindFirstChild("displayPlayers")

if displayPlayers then
    local playerData = displayPlayers:FindFirstChild(playerName)
    if playerData and playerData:FindFirstChild("health") then
        playerData.health.Value = newHealthValue
    end
end
   end,
})
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local SkyboxesFolder = ReplicatedStorage:WaitForChild("skyboxes")
local Skyboxes = {}

for _, skybox in ipairs(SkyboxesFolder:GetChildren()) do
    if skybox:IsA("Sky") then
        table.insert(Skyboxes, skybox.Name)
    end
end

local Dropdown = Tab:CreateDropdown({
   Name = "Choose SkyBox",
   Options = Skyboxes,
   CurrentOption = {Skyboxes[1]},
   MultipleOptions = false,
   Flag = "DropdownSkyBox",
   Callback = function(Options)
       for _, skybox in ipairs(SkyboxesFolder:GetChildren()) do
           if skybox.Name == Options[1] then
               local newSky = skybox:Clone()
               newSky.Parent = game.Lighting
               for _, child in ipairs(game.Lighting:GetChildren()) do
                   if child:IsA("Sky") and child ~= newSky then
                       child:Destroy()
                   end
               end
           end
       end
   end,
})

Tab:CreateButton({
Name = "No fog",
Callback = function()
while wait(0.4) do
game.Lighting.atmosphere.Density = 0
game.Lighting.blur.Enabled = false
game.Lighting.bloom.Enabled = false
game.Lighting.colorCorrection.Enabled = false
end
end,
})

local Dropdown = Tab:CreateDropdown({
   Name = "Game Mode",
   Options = {"", "teamVsTeam", "doubleTrouble"},
   CurrentOption = "",
   MultipleOptions = false,
   Flag = "erly",
   Callback = function(optn)
       local selected = tostring(optn[1] or "")
       local settingsDisplay = game.ReplicatedStorage:FindFirstChild("settingsDisplay")
       if settingsDisplay then
           local gamemode = settingsDisplay:FindFirstChild("gamemode")
           if gamemode and gamemode:IsA("StringValue") then
               gamemode.Value = selected
           end
       end
   end,
})

Tab:CreateButton({
Name = "stats",
Callback = function()
local stats = game.Players.LocalPlayer:WaitForChild("PlayerGui"):WaitForChild("stats")

local gui = Instance.new("ScreenGui")
local frame = Instance.new("ScrollingFrame")
local uiList = Instance.new("UIListLayout")
local Title = Instance.new("ImageButton")
local cls = Instance.new("TextButton", Title)
local clsa = Instance.new("TextButton", Title)

cls.Size = UDim2.new(0, 30, 0, 30)
cls.Text = "X"
cls.Position = UDim2.new(0, 270, 0, 0)
cls.MouseButton1Click:Connect(function()
gui:Destroy()
end)

clsa.Size = UDim2.new(0, 30, 0, 30)
clsa.Text = "-"
clsa.Position = UDim2.new(0, 240, 0, 0)
clsa.MouseButton1Click:Connect(function()
frame.Visible = not frame.Visible
end)

Title.Size = UDim2.new(0, 300, 0, 30)
Title.Active = true
Title.Draggable = true
Title.Parent = gui
Title.Position = UDim2.new(0.5, 0, 0.5, 0)

gui.Parent = game.Players.LocalPlayer.PlayerGui
frame.Parent = Title
frame.Size = UDim2.new(0, 300, 0, 200)
frame.Position = UDim2.new(0, 0, 0, 30)
frame.BackgroundColor3 = Color3.new(0.2, 0.2, 0.2)
frame.BorderSizePixel = 0
frame.ClipsDescendants = true
frame.ZIndex = 10
frame.Name = "AttributesFrame"
frame.CanvasSize = UDim2.new(0, 0, 99, 0)

uiList.Parent = frame
uiList.SortOrder = Enum.SortOrder.LayoutOrder
uiList.Padding = UDim.new(0, 5)

local function createBoolButton(name, value)
    local container = Instance.new("Frame")
    container.Size = UDim2.new(1, -10, 0, 40)
    container.BackgroundTransparency = 1
    container.Parent = frame

    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(0.5, -5, 1, 0)
    label.Position = UDim2.new(0, 0, 0, 0)
    label.BackgroundTransparency = 1
    label.Text = "  " .. name
    label.TextColor3 = Color3.new(1, 1, 1)
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.Parent = container
label.ZIndex = 999

    local button = Instance.new("TextButton")
    button.Size = UDim2.new(0.5, -5, 1, 0)
    button.Position = UDim2.new(0.5, 5, 0, 0)
    button.BackgroundColor3 = value and Color3.new(0, 0.6, 0) or Color3.new(0.6, 0, 0)
    button.TextColor3 = Color3.new(1, 1, 1)
    button.Text = tostring(value)
    button.Parent = container
button.ZIndex = 999

    button.MouseButton1Click:Connect(function()
        value = not value
        button.Text = tostring(value)
        button.BackgroundColor3 = value and Color3.new(0, 0.6, 0) or Color3.new(0.6, 0, 0)
        stats:SetAttribute(name, value)
    end)
end

local function createTextBox(name, value)
    local container = Instance.new("Frame")
    container.Size = UDim2.new(1, -10, 0, 40)
    container.BackgroundTransparency = 1
    container.Parent = frame
container.ZIndex = 999

    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(0.5, -5, 1, 0)
    label.Position = UDim2.new(0, 0, 0, 0)
    label.BackgroundTransparency = 1
    label.Text = "  " .. name
    label.TextColor3 = Color3.new(1, 1, 1)
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.Parent = container
label.ZIndex = 999

    local textBox = Instance.new("TextBox")
    textBox.Size = UDim2.new(0.5, -5, 1, 0)
    textBox.Position = UDim2.new(0.5, 5, 0, 0)
    textBox.BackgroundColor3 = Color3.new(0.3, 0.3, 0.3)
    textBox.TextColor3 = Color3.new(1, 1, 1)
    textBox.Text = tostring(value)
    textBox.ClearTextOnFocus = false
    textBox.Parent = container
textBox.ZIndex = 999

    textBox.FocusLost:Connect(function()
        local newValue = textBox.Text
        stats:SetAttribute(name, newValue)
    end)
end

for name, value in pairs(stats:GetAttributes()) do
    if type(value) == "boolean" then
        createBoolButton(name, value)
    elseif type(value) == "string" then
        createTextBox(name, value)
    end
end
end,
})

local Tab = Window:CreateTab("Beta", 88065516251752)

Tab:CreateButton({
Name = "Anti Dead or Stun (PC/Beta)",
Callback = function()

local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

local step = 1 
local gravitySpeed = 0.5 

local function isOnGround()
    local rayOrigin = humanoidRootPart.Position
    local rayDirection = Vector3.new(0, -3.5, 0) -- Kiểm tra 2 đơn vị phía dưới
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {character} -- Bỏ qua nhân vật
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist

    local raycastResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
    return raycastResult ~= nil 
end

local function moveCharacter()
    if not isOnGround() then
        humanoidRootPart.CFrame = humanoidRootPart.CFrame * CFrame.new(0, -gravitySpeed, 0)
    end
end

game:GetService("RunService").RenderStepped:Connect(function()
    moveCharacter()
end)

local userInput = game:GetService("UserInputService")
local keysHeld = {
    W = false,
    A = false,
    S = false,
    D = false,
    Space = false,
    M = false
}

userInput.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end

    if input.KeyCode == Enum.KeyCode.W then
        keysHeld.W = true
    elseif input.KeyCode == Enum.KeyCode.S then
        keysHeld.S = true
    elseif input.KeyCode == Enum.KeyCode.A then
        keysHeld.A = true
    elseif input.KeyCode == Enum.KeyCode.D then
        keysHeld.D = true
    elseif input.KeyCode == Enum.KeyCode.Space then
        keysHeld.Space = true
    elseif input.KeyCode == Enum.KeyCode.M then
        keysHeld.M = true
    end
end)

userInput.InputEnded:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.W then
        keysHeld.W = false
    elseif input.KeyCode == Enum.KeyCode.S then
        keysHeld.S = false
    elseif input.KeyCode == Enum.KeyCode.A then
        keysHeld.A = false
    elseif input.KeyCode == Enum.KeyCode.D then
        keysHeld.D = false
    elseif input.KeyCode == Enum.KeyCode.Space then
        keysHeld.Space = false
    elseif input.KeyCode == Enum.KeyCode.M then
        keysHeld.M = false
    end
end)

game:GetService("RunService").RenderStepped:Connect(function()
    if keysHeld.W then
        humanoidRootPart.CFrame = humanoidRootPart.CFrame * CFrame.new(0, 0, -step)
    end
    if keysHeld.S then
        humanoidRootPart.CFrame = humanoidRootPart.CFrame * CFrame.new(0, 0, step)
    end
    if keysHeld.A then
        humanoidRootPart.CFrame = humanoidRootPart.CFrame * CFrame.new(-step, 0, 0)
    end
    if keysHeld.D then
        humanoidRootPart.CFrame = humanoidRootPart.CFrame * CFrame.new(step, 0, 0)
    end
    if keysHeld.Space then
        humanoidRootPart.CFrame = humanoidRootPart.CFrame * CFrame.new(0, step, 0)
    end
    if keysHeld.M then
        humanoidRootPart.CFrame = humanoidRootPart.CFrame * CFrame.new(0, -step, 0)
    end
end)
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

humanoidRootPart.Transparency = 0

local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local userInputService = game:GetService("UserInputService")
local anchoredState = false

local function toggleAnchored()
    anchoredState = not anchoredState
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            part.Anchored = anchoredState
        end
    end
    print(anchoredState and "Anchored: ON" or "Anchored: OFF")
end

userInputService.InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed and input.KeyCode == Enum.KeyCode.V then
        toggleAnchored()
    end
end)
local Player = game.Players.LocalPlayer
local ScreenGuie = Instance.new("ScreenGui")
local TextLabel = Instance.new("TextLabel")

ScreenGuie.Name = "HelpTextGUI"
ScreenGuie.Parent = Player:WaitForChild("PlayerGui")

TextLabel.Size = UDim2.new(1, 0, 0, 30)
TextLabel.Position = UDim2.new(0, 0, 1, -30)
TextLabel.BackgroundTransparency = 1
TextLabel.TextColor3 = Color3.new(1, 1, 1)
TextLabel.Font = Enum.Font.SourceSansBold
TextLabel.TextSize = 20
TextLabel.Text = "V: Freeze/Unfreeze  |  WADS: Move  |  Space: Up  |  M: Down"
TextLabel.Parent = ScreenGuie
end,
})

Tab:CreateButton({
Name = "Anti Dead or Stun (Mobile/Beta)",
Callback = function()
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

local step = 1
local gravitySpeed = 0.5 

local buttonsHeld = {
    Up = false,
    Down = false,
    Left = false,
    Right = false,
    Space = false,
    Fall = false
}

local function isOnGround()
    local rayOrigin = humanoidRootPart.Position
    local rayDirection = Vector3.new(0, -3.5, 0)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist

    local raycastResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
    return raycastResult ~= nil
end

local function moveCharacter()
    if buttonsHeld.Up then
        humanoidRootPart.CFrame = humanoidRootPart.CFrame * CFrame.new(0, 0, -step)
    end
    if buttonsHeld.Down then
        humanoidRootPart.CFrame = humanoidRootPart.CFrame * CFrame.new(0, 0, step)
    end
    if buttonsHeld.Left then
        humanoidRootPart.CFrame = humanoidRootPart.CFrame * CFrame.new(-step, 0, 0)
    end
    if buttonsHeld.Right then
        humanoidRootPart.CFrame = humanoidRootPart.CFrame * CFrame.new(step, 0, 0)
    end
    if buttonsHeld.Space then
        humanoidRootPart.CFrame = humanoidRootPart.CFrame * CFrame.new(0, step, 0)
    end
    if buttonsHeld.Fall then
        humanoidRootPart.CFrame = humanoidRootPart.CFrame * CFrame.new(0, -step, 0)
    end

    if not isOnGround() then
        humanoidRootPart.CFrame = humanoidRootPart.CFrame * CFrame.new(0, -gravitySpeed, 0)
    end
end

game:GetService("RunService").RenderStepped:Connect(function()
    moveCharacter()
end)

local screenGui = Instance.new("ScreenGui", player.PlayerGui)
screenGui.Name = "MobileControls"

local function createButton(name, position, size, onPress, onRelease)
    local button = Instance.new("TextButton", screenGui)
    button.Name = name
    button.Size = size
    button.Position = position
    button.Text = name
button.TextSize = 30
    button.BackgroundColor3 = Color3.new(0.5, 0.5, 0.5)
    button.TextColor3 = Color3.new(1, 1, 1)
button.BackgroundTransparency = 0.5

    button.MouseButton1Down:Connect(onPress)
    button.MouseButton1Up:Connect(onRelease)
end

createButton("▲", UDim2.new(0.4, 0, 0.7, 0), UDim2.new(0.2, 0, 0.1, 0), 
    function() buttonsHeld.Up = true end, 
    function() buttonsHeld.Up = false end)

createButton("▼", UDim2.new(0.4, 0, 0.8, 0), UDim2.new(0.2, 0, 0.1, 0), 
    function() buttonsHeld.Down = true end, 
    function() buttonsHeld.Down = false end)

createButton("◀", UDim2.new(0.2, 0, 0.8, 0), UDim2.new(0.2, 0, 0.1, 0), 
    function() buttonsHeld.Left = true end, 
    function() buttonsHeld.Left = false end)

createButton("▶", UDim2.new(0.6, 0, 0.8, 0), UDim2.new(0.2, 0, 0.1, 0), 
    function() buttonsHeld.Right = true end, 
    function() buttonsHeld.Right = false end)

createButton("↑", UDim2.new(0.8, 0, 0.7, 0), UDim2.new(0.2, 0, 0.1, 0), 
    function() buttonsHeld.Space = true end, 
    function() buttonsHeld.Space = false end)

createButton("↓", UDim2.new(0.8, 0, 0.8, 0), UDim2.new(0.2, 0, 0.1, 0), 
    function() buttonsHeld.Fall = true end, 
    function() buttonsHeld.Fall = false end)

-- Add TextBox for adjusting speed
local speedTextBox = Instance.new("TextBox", screenGui)
speedTextBox.Size = UDim2.new(0.2, 0, 0.1, 0)
speedTextBox.Position = UDim2.new(0.4, 0, 0.6, 0)
speedTextBox.Text = tostring(step)
speedTextBox.PlaceholderText = "Speed"
speedTextBox.TextColor3 = Color3.new(1, 1, 1)
speedTextBox.BackgroundColor3 = Color3.new(0.2, 0.2, 0.2)

speedTextBox.FocusLost:Connect(function(enterPressed)
    if enterPressed then
        local newSpeed = tonumber(speedTextBox.Text)
        if newSpeed and newSpeed > 0 then
            step = newSpeed
        else
            speedTextBox.Text = tostring(step)
        end
    end
end)

local button = Instance.new("TextButton")
button.Size = UDim2.new(0, 200, 0, 50)
button.Position = UDim2.new(0, 0, 0.5, -25)
button.Text = "Toggle Anchored"
button.Parent = screenGui

local function toggleAnchored()
    anchoredState = not anchoredState
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            part.Anchored = anchoredState
        end
    end
    button.Text = anchoredState and "Anchored: ON" or "Anchored: OFF"
end

button.MouseButton1Click:Connect(toggleAnchored)

local showGuiButton = Instance.new("TextButton", screenGui)
showGuiButton.Size = UDim2.new(0, 100, 0, 50)
showGuiButton.Position = UDim2.new(0.5, 0, 0, 0)
showGuiButton.Text = "Show GUI"
showGuiButton.BackgroundColor3 = Color3.new(0, 1, 0)
showGuiButton.TextColor3 = Color3.new(1, 1, 1)
showGuiButton.BackgroundTransparency = 0.7
showGuiButton.AnchorPoint = Vector2.new(0.5, 0)

local guiVisible = true

local function toggleGui()
    guiVisible = not guiVisible
    for _, child in pairs(screenGui:GetChildren()) do
        if child ~= showGuiButton then
            child.Visible = guiVisible
        end
    end
    showGuiButton.Text = guiVisible and "Hide GUI" or "Show GUI"
end

showGuiButton.MouseButton1Click:Connect(toggleGui)

local h = Instance.new("TextButton", screenGui)
h.Size = UDim2.new(0.2, 0, 0.1, 0)
h.Position = UDim2.new(0.6, 0, 0.7, 0)
h.Text = "Set Hitbox"
h.BackgroundColor3 = Color3.new(0, 1, 0)
h.TextColor3 = Color3.new(1, 1, 1)
h.BackgroundTransparency = 0.7
h.MouseButton1Click:Connect(function()
    local player = game.Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    
    if humanoidRootPart then
        humanoidRootPart.Transparency = humanoidRootPart.Transparency == 0 and 1 or 0
    end
end)

local i = Instance.new("TextButton", screenGui)
i.Size = UDim2.new(0.2, 0, 0.1, 0)
i.Position = UDim2.new(0.2, 0, 0.7, 0)
i.Text = "Destroy Button"
i.BackgroundColor3 = Color3.new(1, 0, 0)
i.TextColor3 = Color3.new(1, 1, 1)
i.BackgroundTransparency = 0.7
i.MouseButton1Click:Connect(function()
screenGui:Destroy()
end)
end,
})

Tab:CreateButton({
Name = "[🤖] AI For Exe ",
Callback = function()
local Players = game:GetService("Players")
local PathfindingService = game:GetService("PathfindingService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
local Humanoid = Character:WaitForChild("Humanoid")

local TargetPlayer = nil
local Following = false
local Attacking = false

local ScreenGui = Instance.new("ScreenGui", game.Players.LocalPlayer.PlayerGui)
local Frame = Instance.new("Frame", ScreenGui)
Frame.Size = UDim2.new(0, 200, 0, 50)
Frame.Position = UDim2.new(0.5, -100, 0.3, 0)
Frame.BackgroundColor3 = Color3.new(0, 0, 0.2)
Frame.BorderSizePixel = 2
Frame.Draggable = true
Frame.Active = true

local ToggleButton = Instance.new("TextButton", Frame)
ToggleButton.Size = UDim2.new(1, -10, 1, -10)
ToggleButton.Position = UDim2.new(0, 5, 0, 5)
ToggleButton.Text = "BETA!"
ToggleButton.BackgroundColor3 = Color3.new(0, 1, 0)

local function findClosestAlivePlayer()
    local displayPlayers = ReplicatedStorage:FindFirstChild("displayPlayers")
    if not displayPlayers then return nil end

    local closestPlayer = nil
    local closestDistance = math.huge

    for _, playerData in ipairs(displayPlayers:GetChildren()) do
        local healthValue = playerData:FindFirstChild("health")
        if healthValue and healthValue:IsA("NumberValue") and healthValue.Value > 0 then
            local player = Players:FindFirstChild(playerData.Name)
            if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                local distance = (HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).Magnitude
                if distance < closestDistance then
                    closestPlayer = player
                    closestDistance = distance
                end
            end
        end
    end

    return closestPlayer
end

local function updateDisplayPlayers()
    while Following do
        local displayPlayers = ReplicatedStorage:FindFirstChild("displayPlayers")
        if not displayPlayers then
            task.wait(0.1)
        else
            break
        end
    end
end

local function autoJump()
    while Following do
        if Humanoid.MoveDirection.Magnitude > 0 and Humanoid:GetState() ~= Enum.HumanoidStateType.Freefall then
            Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        end
        task.wait(0.3)
    end
end

local function followTarget()
    while Following do
        updateDisplayPlayers()
        TargetPlayer = findClosestAlivePlayer()
        if not TargetPlayer then
            Following = false
            ToggleButton.Text = "Follow"
            ToggleButton.BackgroundColor3 = Color3.new(0, 1, 0)
            Attacking = false
            break
        end

        local TargetRoot = TargetPlayer.Character.HumanoidRootPart
        local Path = PathfindingService:CreatePath({
            AgentRadius = 2,
            AgentHeight = 5,
            AgentCanJump = true,
            AgentJumpHeight = 7,
            AgentWalkableClimb = 2
        })

        Path:ComputeAsync(HumanoidRootPart.Position, TargetRoot.Position)
        local Waypoints = Path:GetWaypoints()

        for _, Waypoint in ipairs(Waypoints) do
            if not Following then break end
            Humanoid:MoveTo(Waypoint.Position)
            Humanoid.MoveToFinished:Wait()
        end
        task.wait(0)
    end
end

local function attackLoop()
    while Attacking do
        ReplicatedStorage.remotes.abilities:FireServer("attack")
        task.wait(0) 
    end
end

ToggleButton.MouseButton1Click:Connect(function()
    if Following then
        Following = false
        Attacking = false
        ToggleButton.Text = "Start"
        ToggleButton.BackgroundColor3 = Color3.new(0, 1, 0)
    else
        Following = true
        Attacking = true
        ToggleButton.Text = "Stop"
        ToggleButton.BackgroundColor3 = Color3.new(1, 0, 0)

        task.spawn(attackLoop) 
        task.spawn(autoJump) 
        followTarget()
    end
end)
end,
})

local Tab = Window:CreateTab("Misc", 18683003750)

local player = game.Players.LocalPlayer

local toggleState = false
local Toggle = Tab:CreateToggle({
    Name = "Can Climb",
    CurrentValue = false,
    Flag = "Toggle_Ladder",
    Callback = function(Value)
        toggleState = Value

        local currentMap = game.Workspace:FindFirstChild("game") and game.Workspace.game:FindFirstChild("currentMap")
        if not currentMap then return end

        for _, part in ipairs(currentMap:GetDescendants()) do
            if part:IsA("BasePart") and part.Name == "ladder" then
                part.Transparency = toggleState and 0 or 1
                part.CanCollide = toggleState
            end
        end
    end,
})

local Toggle = Tab:CreateToggle({
    Name = "Client Abilities No Countdown + Fix Abilities No Countdown",
    CurrentValue = false,
    Flag = "Toggle1",
    Callback = function(Value)
        _G.ToggleState = Value
    end,
})

_G.ToggleState = false

spawn(function()
    while true do
        wait(0)
        if _G.ToggleState then
            if game.ReplicatedStorage.displayPlayers:FindFirstChild(game.Players.LocalPlayer.Name) and 
               game.ReplicatedStorage.displayPlayers[game.Players.LocalPlayer.Name]:FindFirstChild("cooldowns") then

                for _, child in ipairs(game.ReplicatedStorage.displayPlayers[game.Players.LocalPlayer.Name].cooldowns:GetChildren()) do
                    if child:IsA("NumberValue") then
                        child:Destroy()
                    end
                end
            else
               
            end
        end
    end
end)

local player = game.Players.LocalPlayer
local lastExit = nil
local teleportEnabled = false

local function findExit()
    local map = game.Workspace:FindFirstChild("game") and game.Workspace.game:FindFirstChild("currentMap")
    if not map then return nil end

    local exitRing = nil
    for _, obj in ipairs(map:GetDescendants()) do
        if obj:IsA("Model") and obj.Name == "exitRing" and obj.PrimaryPart then
            exitRing = obj
            break
        end
    end

    if exitRing then return exitRing.PrimaryPart end

    local function checkExits(path)
        local exits = path and path:FindFirstChild("default") and path.default:FindFirstChild("exits")
        if exits then
            for _, obj in ipairs(exits:GetChildren()) do
                if obj:IsA("Part") and (obj.Name == "1" or obj.Name == "2" or obj.Name == "3" or obj.Name == "4") and obj:FindFirstChildOfClass("TouchTransmitter") then
                    return obj
                end
            end
        end
        return nil
    end

    return checkExits(map:FindFirstChild("you can't run")) or checkExits(map:FindFirstChild("base"))
end

task.spawn(function()
    while true do
        if teleportEnabled then
            local character = player.Character
            if character and character:FindFirstChild("HumanoidRootPart") then
                local exit = findExit()
                if exit and exit ~= lastExit then
                    lastExit = exit
                    character.HumanoidRootPart.CFrame = exit.CFrame
                end
            end
        end
        task.wait(0.5)
    end
end)

local Toggle = Tab:CreateToggle({
    Name = "Auto Exit",
    CurrentValue = false,
    Flag = "Toggle_Teleport",
    Callback = function(Value)
        teleportEnabled = Value
    end,
})

Tab:CreateButton({
Name = "Aimbot",
Callback = function()
local gui = Instance.new("ScreenGui") local title = Instance.new("TextLabel") local frame = Instance.new("TextButton") local close = Instance.new("TextButton") local minimize = Instance.new("TextButton") local textBox = Instance.new("TextBox") local aimButton = Instance.new("TextButton")

gui.Parent = game.CoreGui title.Parent = gui title.Size = UDim2.new(0, 200, 0, 50) title.Position = UDim2.new(0.5, -100, 0.3, 0) title.BackgroundColor3 = Color3.fromRGB(50, 50, 50) title.Text = "Simple Aimbot" title.TextColor3 = Color3.fromRGB(255, 255, 255)

title.Active = true title.Draggable = true

frame.Parent = title frame.Size = UDim2.new(1, 0, 3, 0) frame.Position = UDim2.new(0, 0, 1, 0) frame.BackgroundColor3 = Color3.fromRGB(70, 70, 70) frame.Text = "" frame.AutoButtonColor = false

close.Parent = title close.Size = UDim2.new(0, 30, 0, 30) close.Position = UDim2.new(1, -35, 0, 10) close.BackgroundColor3 = Color3.fromRGB(200, 50, 50) close.Text = "X" close.TextColor3 = Color3.fromRGB(255, 255, 255)

minimize.Parent = title minimize.Size = UDim2.new(0, 30, 0, 30) minimize.Position = UDim2.new(1, -55, 0, 25) minimize.BackgroundColor3 = Color3.fromRGB(200, 200, 50) minimize.Text = "-" minimize.TextColor3 = Color3.fromRGB(255, 255, 255) minimize.AnchorPoint = Vector2.new(0.5, 0.5)

textBox.Parent = frame textBox.Size = UDim2.new(0.8, 0, 0, 30) textBox.Position = UDim2.new(0.1, 0, 0.1, 0) textBox.BackgroundColor3 = Color3.fromRGB(255, 255, 255) textBox.PlaceholderText = "Enter Name"

aimButton.Parent = frame aimButton.Size = UDim2.new(0.8, 0, 0, 30) aimButton.Position = UDim2.new(0.1, 0, 0.3, 0) aimButton.BackgroundColor3 = Color3.fromRGB(100, 100, 255) aimButton.Text = "Start Aimbot" aimButton.TextColor3 = Color3.fromRGB(255, 255, 255)

local aimbotEnabled = false local runService = game:GetService("RunService") local players = game:GetService("Players") local camera = game.Workspace.CurrentCamera

local function getTargetPlayer(name) for _, player in pairs(players:GetPlayers()) do if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then local displayName = player.DisplayName:lower() local username = player.Name:lower() if displayName:find(name:lower()) or username:find(name:lower()) then return player.Character.HumanoidRootPart end end end return nil end

aimButton.MouseButton1Click:Connect(function() local targetName = textBox.Text if targetName ~= "" then aimbotEnabled = not aimbotEnabled aimButton.Text = aimbotEnabled and "Stop Aimbot" or "Start Aimbot" if aimbotEnabled then runService:BindToRenderStep("Aimbot", Enum.RenderPriority.Camera.Value, function() local target = getTargetPlayer(targetName) if target then camera.CFrame = CFrame.new(camera.CFrame.Position, target.Position) end end) else runService:UnbindFromRenderStep("Aimbot") end else print("Please enter a name!") end end)

players.PlayerAdded:Connect(function() if aimbotEnabled then local target = getTargetPlayer(textBox.Text) if not target then aimButton.Text = "Start Aimbot" aimbotEnabled = false end end end)

players.PlayerRemoving:Connect(function() if aimbotEnabled then local target = getTargetPlayer(textBox.Text) if not target then aimButton.Text = "Start Aimbot" aimbotEnabled = false end end end)

minimize.MouseButton1Click:Connect(function() frame.Visible = not frame.Visible end)

close.MouseButton1Click:Connect(function() gui:Destroy() end) end,
})

Tab:CreateButton({
Name = "Jump No Delay",
Callback = function()
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
local UserInputService = game:GetService("UserInputService")
local jumping = false

local function isGrounded()
    local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        return humanoid:GetState() == Enum.HumanoidStateType.Running or humanoid:GetState() == Enum.HumanoidStateType.Landed
    end
    return false
end

local function jump()
    if isGrounded() then
        LocalPlayer.Character:FindFirstChildOfClass("Humanoid"):ChangeState(Enum.HumanoidStateType.Jumping)
    end
end

local function startJumping()
    jumping = true
    while jumping do
        jump()
        wait(0)
    end
end

local function stopJumping()
    jumping = false
end

local function removeJumpButton()
    local touchGui = PlayerGui:FindFirstChild("TouchGui")
    if touchGui then
        local touchControlFrame = touchGui:FindFirstChild("TouchControlFrame")
        if touchControlFrame then
            local jumpButton = touchControlFrame:FindFirstChild("JumpButton")
            if jumpButton then
                jumpButton:Destroy()
            end
        end
    end
end

local function createJumpButton()
    local touchGui = PlayerGui:FindFirstChild("TouchGui")
    if touchGui then
        local touchControlFrame = touchGui:FindFirstChild("TouchControlFrame")
        if touchControlFrame then
            local jumpButton = Instance.new("ImageButton")
            jumpButton.Name = "JumpButton"
            jumpButton.Size = UDim2.new(0, 120, 0, 120)
            jumpButton.Position = UDim2.new(1, -150, 1, -150)
            jumpButton.Parent = touchControlFrame
            jumpButton.BackgroundColor3 = Color3.new(0, 0, 0)
            jumpButton.MouseButton1Down:Connect(startJumping)
            jumpButton.MouseButton1Up:Connect(stopJumping)
        end
    end
end

UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if gameProcessedEvent then return end
    if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == Enum.KeyCode.Space then
        startJumping()
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == Enum.KeyCode.Space then
        stopJumping()
    end
end)

removeJumpButton()
createJumpButton()
end,
})

local running = false 

local Toggle = Tab:CreateToggle({
   Name = "Toggle laserHit Sound (Spam)",
   CurrentValue = false,
   Flag = "LaserHitToggle",
   Callback = function(Value)
      running = Value 
      if running then
         while running and wait() do
            game:GetService("ReplicatedStorage"):WaitForChild("remotes"):WaitForChild("actions"):FireServer("laserHit")
         end
      end
   end,
})

Tab:CreateButton({
Name = "One Click laserHit Sound",
Callback = function()
            game:GetService("ReplicatedStorage"):WaitForChild("remotes"):WaitForChild("actions"):FireServer("laserHit")
end,
})



Tab:CreateButton({
Name = "Floor (Selection Intro) canCollide",
Callback = function()
game.Workspace.game.selectionIntro.floor.floor.CanCollide = true
end,
})

Tab:CreateButton({
Name = "All Abilities (Unfinished)",
Callback = function()
loadstring(game:HttpGet("https://raw.githubusercontent.com/Biem6ondo/Sonic.exe/refs/heads/main/allskill.txt"))()
end,
})

local idtwo = false

local Toggle = Tab:CreateToggle({
    Name = "Hitbox mode",
    CurrentValue = false,
    Flag = "Toggle1",
    Callback = function(Value)
        idtwo = Value
        if not idtwo then
            for _, v in pairs(workspace:GetDescendants()) do
                if v:IsA("BasePart") and v.Name == "hitbox" then
                    v.Transparency = 1
                end
            end
        else
            task.spawn(function()
                while idtwo do
                    for _, v in pairs(workspace:GetDescendants()) do
                        if v:IsA("BasePart") and v.Name == "hitbox" then
                            v.Transparency = 0.5
                        end
                    end
                    wait(2)
                end
            end)
        end
    end
})

local hitboxSizes = {}

for _, v in pairs(workspace:GetDescendants()) do
    if v:IsA("BasePart") and v.Name == "hitbox" then
        hitboxSizes[v] = v.Size
    end
end

Tab:CreateButton({
Name = "+5 Hitbox",
Callback = function()
for _, v in pairs(workspace:GetDescendants()) do
if v:IsA("BasePart") and v.Name == "hitbox" then
v.Size = v.Size + Vector3.new(5, 5, 5)
end
end
end,
})

Tab:CreateButton({
Name = "-5 Hitbox",
Callback = function()
for _, v in pairs(workspace:GetDescendants()) do
if v:IsA("BasePart") and v.Name == "hitbox" then
v.Size = v.Size - Vector3.new(5, 5, 5)
end
end
end,
})

local executorSupportsHook = pcall(getrawmetatable, game)
local xValue = nil
local blockInvoke = true
local runningRandom = false

local commands = {}

commands["help"] = function()
    return "Commands: help, random x y, stop (disable block), stoprandom (stop random loop), enter a number to set fake ping"
end

commands["random"] = function(x, y)
    x, y = tonumber(x), tonumber(y)
    if x and y then
        runningRandom = true
        spawn(function()
            while runningRandom do
                xValue = math.random(x, y)
                wait(2)
            end
        end)
        return "Random mode activated (" .. x .. " to " .. y .. ")"
    end
    return "Error: Invalid parameters"
end

commands["stoprandom"] = function()
    runningRandom = false
    return "Random mode stopped"
end

commands["stop"] = function()
    blockInvoke = false
    return "InvokeServer block disabled"
end

local function executeCommand(input)
    local num = tonumber(input)
    if num then
        xValue = num
        blockInvoke = true
        return "Fake ping set to " .. num
    end

    local words = {}
    for word in input:gmatch("%S+") do
        table.insert(words, word)
    end

    if #words == 1 and commands[words[1]] then
        return commands[words[1]]()
    elseif #words == 3 and commands[words[1]] then
        return commands[words[1]](words[2], words[3])
    end

    return "Command does not exist or has incorrect syntax"
end

local inputPlaceholder = executorSupportsHook and "Enter a number or command..." or "Executor not supported"

local Input = Tab:CreateInput({
   Name = "Set Fake Ping (Type Help)",
   CurrentValue = "",
   PlaceholderText = inputPlaceholder,
   RemoveTextAfterFocusLost = false,
   Flag = "Input1",
   Callback = function(Text)
       local result = executeCommand(Text)
       if result then
           Rayfield:Notify({
               Title = "Ping Notification",
               Content = result,
               Duration = 4,
               Image = "rewind",
           })
       end
   end,
})

if executorSupportsHook then
    local mt = getrawmetatable(game)
    setreadonly(mt, false)

    local oldNamecall = mt.__namecall

    mt.__namecall = newcclosure(function(self, ...)
        local args = {...}
        if self == game.ReplicatedStorage.remotes.gameStats and getnamecallmethod() == "InvokeServer" then
            if blockInvoke and xValue then
                return oldNamecall(self, 0, xValue)
            end
        end
        return oldNamecall(self, unpack(args))
    end)

    setreadonly(mt, true)



else
    Rayfield:Notify({
        Title = "Executor Error",
        Content = "Your executor does not support metatable hooking.",
        Duration = 5,
        Image = "rewind",
    })
end

local RunService = game:GetService("RunService")

local function getPing()
    return game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue()
end

task.spawn(function()
    while true do
        if getPing() >= 5000 then
Rayfield:Notify({
   Title = "Fixing Ping",
   Content = "Your Ping Is Being Fixed, Please Wait!",
   Duration = 1,
   Image = "rewind",
})


for _, v in pairs({ToggleHeatWave, ToggleOrb, ToggleFlashBang, SliverBarrier, TailsDollTrap, ReviveActions, ToggleGrapple, TailsDollSlash, Shadow_homingAttackState_attacking, Shadow_boostState_landed}) do  
    v:Set(false)  
end

        end
        task.wait(5)
    end
end)

local Player = game:GetService("Players").LocalPlayer

Player.CharacterAdded:Connect(function(Character)
    canturnoff:Set(false)
canturnoffa:Set(false)
end)

ScreenGui:Destroy()
print("Disabled welcome notify because is suck")
end
